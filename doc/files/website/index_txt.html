<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: index.txt</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>index.txt</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>website/index.txt
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jul 18 20:53:17 -0400 2008</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
h1. rewrite
</p>
<p>
h1. &amp;x2192; &#8216;rewrite&#8216;
</p>
<p>
h2. What
</p>
<p>
Rewrite adds sexp-rewriting metaprogramming to Ruby. Or in plain English,
Rewrite is a collection of features for Ruby programming like an
implementation of &quot;andand&quot;:<a
href="http://andand.rubyforge.org">andand.rubyforge.org</a>. What makes
Rewrite&#8216;s versions of these features different and possibly useful is
that they are implemented by rewriting your Ruby code rather than by
opening up classes like Kernel, Object, Nil, or Symbol.
</p>
<p>
h2. Installing
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt;sudo gem install rewrite&lt;/pre&gt;
</p>
<p>
h2. The basics
</p>
<p>
In your environment.rb file (Rails) or at the top of your source code file,
include @<a href="../../classes/Rewrite/With.html">Rewrite::With</a>@ and
@<a href="../../classes/Rewrite/Prelude.html">Rewrite::Prelude</a>@:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; include <a
href="../../classes/Rewrite/With.html">Rewrite::With</a> include <a
href="../../classes/Rewrite/Prelude.html">Rewrite::Prelude</a>
&lt;/pre&gt;This makes the @with@ method available to your souce code, so
you can write:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; with(andand) do
</p>
<pre>
        ...
        first_name = Person.find_by_last_name('Braithwaite').andand.first_name
        ...
</pre>
<p>
end &lt;/pre&gt;The special magic here is that instead of opening up the
Object and Nil classes to add _#andand_, Rewrite rewrites the ruby code
inside the do/end block so that it looks roughly like this:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; with(andand) do
</p>
<pre>
        ...
        first_name = lambda { |__1234567__|
                if __1234567__.nil?
                        nil
                else
                        __1234567__.first_name
                end
        }.call(Person.find_by_last_name('Braithwaite'))
        ...
</pre>
<p>
end &lt;/pre&gt;That&#8216;s a big win because you can use the
metaprogramming features you want without worrying that you are breaking
anybody else&#8216;s code. If you use an implementation of andand that
relies on opening the Object and Nil classes, how do you know you
aren&#8216;t (a) breaking some other code somewhere else, or (b) exposing
your code to being broken if something else changes the andand methods?
</p>
<p>
h2. What problem does rewrite solve?
</p>
<p>
Recall that when you use the “standard” implementation of things like
&quot;andand&quot;:<a
href="http://andand.rubyforge.org">andand.rubyforge.org</a>/ or
&quot;try&quot;:<a
href="http://ozmm.org/posts/try.html">ozmm.org/posts/try.html</a>, you are
openly modifying core classes like Object.
</p>
<p>
Therefore, you are reaching out and touching every line of code in your
project. You probably aren’t breaking everything, but even if the chance
of introducing a bug by adopting something like “try” is infinitesimal
for each source code file in your project, the chance grows greater and
greater as your application grows.
</p>
<p>
The problem is that you are introducing a change on Object, and everything
depends on object. This is very different than introducing a change in your
code. In that case, only the other bits of code that directly depend on
your code are at risk.
</p>
<p>
Also, imagine if you introduce try and are careful not to break anything.
Now somebody else wakes up one day and decides they need a method that
works like Prototype’s &quot;Try.these&quot;:<a
href="http://www.prototypejs.org/api/utility/try-these">www.prototypejs.org/api/utility/try-these</a>.
They call it “try.” They just broke your code, dude! Not only are you
making everything dependant upon your version of try, but your code is
dependent upon everyone else not breaking try as well. It’s a train-wreck
waiting to happen.
</p>
<p>
Rewrite restricts things like andand or try to your code and your code
alone. Sure, if you introduce a bug in your code, you may break things that
directly depend on your code. But if you introduce “try” using rewrite
instead of modifying Object, you will not reach out across your project and
break something entirely unrelated that happens to have defined its own
version of try in a completely different way.
</p>
<p>
h2. called_by_name
</p>
<p>
See &quot;Macros, Hygiene, and Call By Name in Ruby&quot;:<a
href="http://weblog.raganwald.com/2008/06/macros-hygiene-and-call-by-name-in-ruby.html">weblog.raganwald.com/2008/06/macros-hygiene-and-call-by-name-in-ruby.html</a>
for details, more docs to come presently&#8230;
</p>
<p>
h2. Unhygienic rewriting
</p>
<p>
A new feature every much like a new human being: Vulnerable, disruptive,
and a complete mess:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; include <a
href="../../classes/Rewrite/With.html">Rewrite::With</a>
</p>
<p>
andand = <a
href="../../classes/Rewrite/ByExample/Unhygienic.html">Rewrite::ByExample::Unhygienic</a>.
</p>
<pre>
  from(:receiver, :message, [:parameters]) {
    receiver.andand.message(parameters)
  }.to {
    lambda { |andand_temp|
      andand_temp.message(parameters) if andand_temp
    }.call(receiver)
  }
</pre>
<p>
with (andand) do
</p>
<pre>
        # ...
        foo.andand.bar(:bash, blitz(5))
        # ...
</pre>
<p>
end &lt;/pre&gt;
</p>
<p>
becomes:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; # &#8230; lambda { |andand_temp|
</p>
<pre>
  andand_temp.bar(:bash, blitz(5)) if andand_temp
</pre>
<p>
}.call(foo) # &#8230; &lt;/pre&gt;
</p>
<p>
h2. How does it work?
</p>
<p>
Rewrite takes your code, converts it to an sexp with Parse Tree, then
rewrites the sexp using one or more rewriters you specify. Finally, it
converts the sexp back to Ruby with Ruby2Ruby and evals it. It does this
when the code is first read, not every time it is invoked, so we mitigate
the “do not use andand in a tight loop” problem.
</p>
<p>
For example, rewrite converts this:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt;
emails.find_by_email(email).try(:destroy) &lt;/pre&gt;
</p>
<p>
Into:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; lambda { |receiver, method|
</p>
<pre>
   receiver.send(method) if receiver.respond_to? method
 }.call(emails.find_by_email(email), :destroy)
</pre>
<p>
&lt;/pre&gt;
</p>
<p>
And this:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt;
</p>
<pre>
 numbers.andand.inject(base_sum()) { |total, number| total + number }
</pre>
<p>
&lt;/pre&gt;
</p>
<p>
Into:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt;
</p>
<pre>
 lambda { |__1234567890__|
   if __1234567890__.nil?
     nil
   else
     __1234567890__.inject(base_sum()) { |total, number| total + number }
   end
 }.call(numbers)
</pre>
<p>
&lt;/pre&gt;
</p>
<p>
Note that with the examples, the names “andand” and “try”
completely go away. If someone else defines a try method elsewhere, it will
not affect your code because your code never executes a method called try.
</p>
<p>
h2. How to love Rewrite without destroying Ruby
</p>
<p>
If you write:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; include <a
href="../../classes/Rewrite/With.html">Rewrite::With</a> include <a
href="../../classes/Rewrite/Prelude.html">Rewrite::Prelude</a>
</p>
<p>
&#8230; &lt;/pre&gt;in Kernel context (such as in Rails&#8217;
@environment.rb@), you are adding methods to the global namespace. You can
include Rewrite in one or more classes where you want to use its features:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; class Person
</p>
<pre>
        include Rewrite::With
        include Rewrite::Prelude

        ...
</pre>
<p>
end &lt;/pre&gt;Or you can go 100% safe and avoid adding anything to
existing namespaces:
</p>
<p>
&lt;pre syntax=&quot;ruby&quot;&gt; class Person
</p>
<pre>
        Rewrite.with(Rewrite::Prelude::Andand.new) do
           ...
        end
</pre>
<p>
end &lt;/pre&gt;It&#8216;s entirely up to you.
</p>
<p>
h2. What goodies do I get?
</p>
<p>
Check the &quot;rdocs&quot;:<a
href="http://rewrite.rubyforge.org/rdoc">rewrite.rubyforge.org/rdoc</a>/,
specifically the docs for &quot;<a
href="../../classes/Rewrite/Prelude.html">Rewrite::Prelude</a>&quot;:<a
href="http://rewrite.rubyforge.org/rdoc/classes/Rewrite/Prelude.html">rewrite.rubyforge.org/rdoc/classes/Rewrite/Prelude.html</a>.
</p>
<p>
h2. Current Status
</p>
<p>
This is just a proof-of-concept at the moment. Writing new features is
torturous, so I&#8216;m not going to suggest you write your own until I
figure out how to make that easy.
</p>
<p>
h2. How to submit patches
</p>
<p>
Read the &quot;8 steps for fixing other people&#8216;s code&quot;:<a
href="http://drnicwilliams.com/2007/06/01/8-steps-for-fixing-other-peoples-code">drnicwilliams.com/2007/06/01/8-steps-for-fixing-other-peoples-code</a>/
and for section &quot;8b: Submit patch to Google Groups&quot;:<a
href="http://drnicwilliams.com/2007/06/01/8-steps-for-fixing-other-peoples-code/#8b-google-groups">drnicwilliams.com/2007/06/01/8-steps-for-fixing-other-peoples-code/#8b-google-groups</a>,
use the Google Group above.
</p>
<p>
The trunk repository is <tt>svn://rubyforge.org/var/svn/rewrite/trunk</tt>
for anonymous access.
</p>
<p>
h3. Build and test instructions
</p>
<p>
&lt;pre&gt;cd rewrite rake test rake install_gem&lt;/pre&gt;
</p>
<p>
h2. License
</p>
<p>
This code is free to use under the terms of the MIT license.
</p>
<p>
h2. Contact
</p>
<p>
Comments are welcome. Send an email to &quot;Reg Braithwaite&quot;:<a
href="mailto:raganwald+rewrite@gmail.com">raganwald+rewrite@gmail.com</a>
email via the &quot;forum&quot;:<a
href="http://groups.google.com/group/rewrite">groups.google.com/group/rewrite</a>
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>